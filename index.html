<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Study Slingshot - Universal Loader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* --- CSS STYLES --- */
    * { 
      box-sizing: border-box; 
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 100%);
      overflow: hidden;
      height: 100vh;
      position: relative;
    }

    /* --- DASHBOARD STYLES --- */
    #dashboard {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 0.5s ease;
      flex-direction: column;
    }

    .dashboard-card {
      background: white;
      padding: 40px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      text-align: center;
      max-width: 90%;
      width: 400px;
    }

    .dashboard-card h1 {
      font-size: 2em;
      color: #333;
      margin-bottom: 10px;
    }

    .dashboard-card p {
      margin-bottom: 20px;
      color: #666;
    }

    .select-group {
      margin-bottom: 15px;
      text-align: left;
    }

    .select-group label {
      display: block;
      font-weight: bold;
      margin-bottom: 5px;
      color: #444;
    }

    .select-group select {
      width: 100%;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background-color: #f9f9f9;
      font-size: 1em;
      appearance: none; /* Remove default styling */
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%23333'%3e%3cpath d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px top 50%;
      background-size: 16px;
    }


    .start-btn {
      background-color: #e53935; /* Red, Angry Birds style */
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.1em;
      font-weight: bold;
      transition: background-color 0.3s, transform 0.1s;
      box-shadow: 0 4px 10px rgba(229, 57, 53, 0.4);
    }

    .start-btn:hover {
      background-color: #c62828;
      transform: translateY(-2px);
    }

    /* --- GAME UI STYLES --- */
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #canvas {
      display: block;
      background: transparent;
      width: 100%;
      height: 100%;
    }

    #question-area {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 15px 30px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      max-width: 90%;
      min-width: 400px;
      text-align: center;
      z-index: 50;
    }

    #question-text {
      font-size: 1.2em;
      font-weight: bold;
      color: #1e88e5; /* Blue for question */
    }

    #game-info {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 15px;
        border-radius: 8px;
        font-size: 0.9em;
        z-index: 50;
    }

    /* --- Target/Box Styles (options) --- */
    .box {
      background: #4caf50; /* Green for target */
      color: white;
      border-radius: 8px;
      padding: 10px;
      text-align: center;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      border: 3px solid #388e3c;
      transition: all 0.2s ease-out;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .box.hit {
        animation: hitEffect 0.5s ease-out forwards;
    }

    @keyframes hitEffect {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2) rotate(5deg); opacity: 0.8; }
      100% { transform: scale(0); opacity: 0; }
    }

    /* --- Confetti Effect (Simple Fall) --- */
    @keyframes fall {
      to { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }
  </style>
</head>
<body>

  <div id="game-container">
    <div id="game-info">
        Level: <span id="level-display">1</span> | Score: <span id="score-display">0</span>
    </div>
    <div id="question-area">
      <p id="question-text">Loading game questions...</p>
    </div>
    <canvas id="canvas"></canvas>
  </div>

  <!-- Dashboard for Game Selection -->
  <div id="dashboard">
    <div class="dashboard-card">
      <h1>Study Slingshot</h1>
      <p>Select your subject and chapter to start the game!</p>
      
      <div id="selection-area">
        <!-- Dropdowns will be inserted here by JavaScript -->
        <p>Loading question data...</p>
      </div>
      
      <button class="start-btn" id="start-game-btn" disabled>Start Game</button>
      <p id="loading-message" style="margin-top: 10px; color: #ff9800;">Please wait while questions load...</p>
    </div>
  </div>

  <script>
    // --- CANVAS AND CONTEXT SETUP ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let animationFrameId;
    let paused = false;
    let score = 0;
    let level = 1;

    // --- GAME STATE VARIABLES ---
    let allQuestionsData = {}; // Stores all fetched questions (Subject -> Class -> Chapter -> Questions[])
    let currentQuestions = []; // The array of questions for the current chapter
    let currentQuestionIndex = 0;
    let targetBoxes = []; // Array of DOM elements for options
    let correctOptionIndex = -1; // Index of the correct option

    // --- BIRD & SLINGSHOT CONFIG ---
    let slingshotX = 100;
    let currentSlingshotY = canvas.height / 2; // Will be set on resize
    const maxDragDistance = 150;
    const birdRadius = 20;

    let bird = {
      x: slingshotX - 20,
      y: 0, // Will be initialized
      radius: birdRadius,
      color: '#e53935', // Angry Bird Red
      vx: 0,
      vy: 0,
      launched: false,
      dragging: false,
      dead: false,
      launchPoint: { x: 0, y: 0 }
    };

    // --- UTILITY FUNCTIONS ---
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Update slingshot Y position
      currentSlingshotY = canvas.height - 100;
      slingshotX = canvas.width * 0.1;

      // Re-initialize bird position if not launched
      if (!bird.launched) {
        bird.x = slingshotX - birdRadius;
        bird.y = currentSlingshotY;
        bird.launchPoint = { x: bird.x, y: bird.y };
      }
      
      // Redraw everything on resize
      if (!paused) {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animate();
      }
    }
    
    // --- DASHBOARD LOGIC (MODIFIED FOR SELECTION) ---

    // Function to fetch questions data from questions.json
    async function fetchQuestionsData() {
        const loadingMessage = document.getElementById('loading-message');
        const startButton = document.getElementById('start-game-btn');
        loadingMessage.textContent = 'Fetching questions from questions.json...';
        
        // --- START: External Data Fetch Logic ---
        try {
            // Assumes questions.json is in the same directory and structured correctly
            const response = await fetch('questions.json');
            
            // Check if the file was found and the fetch was successful
            if (!response.ok) {
                // If the response is not OK (e.g., 404 Not Found)
                if (response.status === 404) {
                     throw new Error('questions.json file not found. Please ensure it is uploaded and named exactly "questions.json".');
                }
                throw new Error(`Network response was not ok, status: ${response.status}`);
            }
            
            allQuestionsData = await response.json();
            console.log("Questions data loaded successfully from questions.json.");
            
        } catch (error) {
            console.error("Error fetching question data:", error.message);
            loadingMessage.textContent = `Error: Could not load questions. ${error.message}`;
            startButton.disabled = true;
            // Clear allQuestionsData to prevent proceeding with incomplete data
            allQuestionsData = {}; 
            return;
        }
        // --- END: External Data Fetch Logic ---

        // If data is loaded, setup the dropdowns
        if (Object.keys(allQuestionsData).length > 0) {
            setupSelectionUI();
            startButton.disabled = false;
            loadingMessage.textContent = 'Data loaded. Ready to play!';
        } else {
            // This handles cases where the JSON file was empty or malformed after fetching
            loadingMessage.textContent = 'Questions file loaded but contains no data. Cannot start game.';
            startButton.disabled = true;
        }
    }

    function setupSelectionUI() {
        const selectionArea = document.getElementById('selection-area');
        selectionArea.innerHTML = ''; // Clear initial message

        // 1. Subject Dropdown
        const subjects = Object.keys(allQuestionsData);
        if (subjects.length === 0) return;

        const subjectGroup = createDropdownGroup('subject', 'Subject:');
        subjects.forEach(sub => {
            subjectGroup.select.add(new Option(sub, sub));
        });
        selectionArea.appendChild(subjectGroup.div);
        
        // 2. Class Dropdown (Initially populate based on first subject)
        const classGroup = createDropdownGroup('class', 'Class:');
        selectionArea.appendChild(classGroup.div);

        // 3. Chapter Dropdown (Initially empty)
        const chapterGroup = createDropdownGroup('chapter', 'Chapter:');
        selectionArea.appendChild(chapterGroup.div);

        // Event Listeners for cascading updates
        subjectGroup.select.addEventListener('change', () => updateClassDropdown(subjectGroup.select.value));
        classGroup.select.addEventListener('change', () => updateChapterDropdown(subjectGroup.select.value, classGroup.select.value));

        // Initial population
        updateClassDropdown(subjectGroup.select.value);
    }

    function createDropdownGroup(id, labelText) {
        const div = document.createElement('div');
        div.className = 'select-group';

        const label = document.createElement('label');
        label.setAttribute('for', id);
        label.textContent = labelText;

        const select = document.createElement('select');
        select.id = id;
        select.name = id;

        div.appendChild(label);
        div.appendChild(select);
        return { div, select };
    }

    function updateClassDropdown(selectedSubject) {
        const classSelect = document.getElementById('class');
        classSelect.innerHTML = ''; // Clear existing options
        
        const classes = Object.keys(allQuestionsData[selectedSubject] || {});
        classes.forEach(cls => {
            classSelect.add(new Option(cls, cls));
        });

        // Trigger chapter update for the newly selected class/subject combination
        updateChapterDropdown(selectedSubject, classSelect.value);
    }

    function updateChapterDropdown(selectedSubject, selectedClass) {
        const chapterSelect = document.getElementById('chapter');
        chapterSelect.innerHTML = ''; // Clear existing options

        const chapters = Object.keys(allQuestionsData[selectedSubject]?.[selectedClass] || {});
        chapters.forEach(chp => {
            chapterSelect.add(new Option(chp.replace(/_/g, ' '), chp)); // Display friendly name, use key for data
        });
    }


    function setupDashboard() {
      // Setup the start button listener after data is loaded
      document.getElementById('start-game-btn').addEventListener('click', () => {
        const subject = document.getElementById('subject').value;
        const className = document.getElementById('class').value;
        const chapter = document.getElementById('chapter').value;
        
        if (subject && className && chapter && allQuestionsData[subject][className][chapter]) {
            const questions = allQuestionsData[subject][className][chapter];
            startGame(questions);
        } else {
            console.error("Invalid selection or missing questions.");
        }
      });
      
      // Start fetching the data immediately
      fetchQuestionsData();
    }

    // --- GAME CONTROL FUNCTIONS (MODIFIED) ---

    // Replaced the original startGame with one that accepts question data
    function startGame(questionsArray) {
      if (questionsArray.length === 0) {
        // Use a modal or custom UI instead of alert()
        console.error("No questions for this chapter!");
        const questionText = document.getElementById('question-text');
        questionText.textContent = "Error: No questions found for this selection!";
        setTimeout(() => questionText.textContent = "Please select a different chapter on the start screen.", 3000);
        
        // Re-show dashboard to select a different chapter
        document.getElementById('dashboard').style.display = 'flex';
        document.getElementById('dashboard').style.opacity = '1';
        return;
      }

      currentQuestions = questionsArray;
      currentQuestionIndex = 0;
      score = 0;
      level = 1;

      document.getElementById('dashboard').style.opacity = '0';
      setTimeout(() => {
        document.getElementById('dashboard').style.display = 'none';
        paused = false;
        nextQuestion();
        animate();
      }, 500); // Wait for transition
    }

    function resetBird() {
      bird.x = slingshotX - bird.radius;
      bird.y = currentSlingshotY;
      bird.vx = 0;
      bird.vy = 0;
      bird.launched = false;
      bird.dead = false;
      bird.dragging = false;
      bird.launchPoint = { x: bird.x, y: bird.y };
      
      // Ensure boxes are visible for the new question
      targetBoxes.forEach(box => box.style.opacity = '1');
    }

    function nextQuestion() {
      if (currentQuestionIndex >= currentQuestions.length) {
        // Chapter Complete
        gameEnd(true);
        return;
      }
      
      const questionData = currentQuestions[currentQuestionIndex];
      
      // Display the question on the main screen
      document.getElementById('question-text').textContent = questionData.question;
      
      document.getElementById('level-display').textContent = currentQuestionIndex + 1;
      document.getElementById('score-display').textContent = score;

      correctOptionIndex = questionData.correct; // Store correct index
      
      createTargetBoxes(questionData.options);
      resetBird();
    }


    function gameEnd(win) {
        paused = true;
        let finalMessage = win ? 
            `Chapter Complete! Great work! Final Score: ${score}` : 
            `Game Over! You finished ${currentQuestionIndex} questions. Final Score: ${score}`;
        
        document.getElementById('dashboard').style.display = 'flex';
        document.getElementById('dashboard').style.opacity = '1';

        const dashboardCard = document.querySelector('.dashboard-card');
        dashboardCard.innerHTML = `
            <h1>${win ? 'Chapter Complete!' : 'Game Over'}</h1>
            <p>${finalMessage}</p>
            <button class="start-btn" onclick="window.location.reload()">Play Again</button>
        `;
    }

    // --- TARGET RENDERING (MODIFIED) ---

    function createTargetBoxes(options) {
      targetBoxes.forEach(box => box.remove()); // Clear old boxes
      targetBoxes = [];

      const container = document.getElementById('game-container');
      
      // Define positions for targets (adjust Y based on screen height)
      const positions = [
        { x: canvas.width * 0.75, y: canvas.height * 0.75 },
        { x: canvas.width * 0.85, y: canvas.height * 0.60 },
        { x: canvas.width * 0.70, y: canvas.height * 0.45 },
        { x: canvas.width * 0.88, y: canvas.height * 0.30 },
      ];
      
      options.forEach((optionText, index) => {
        const pos = positions[index % positions.length];
        const box = document.createElement('div');
        box.className = 'box';
        box.textContent = optionText;
        box.style.position = 'absolute';
        box.style.left = `${pos.x}px`;
        box.style.top = `${pos.y}px`;
        box.style.width = '150px';
        box.style.height = '50px';
        box.dataset.optionIndex = index;
        
        container.appendChild(box);
        targetBoxes.push(box);
      });
    }

    // --- GAME CORE LOGIC ---

    function drawSlingshot() {
      ctx.fillStyle = '#6d4c41'; // Brown base
      ctx.beginPath();
      ctx.moveTo(slingshotX - 30, currentSlingshotY + 30);
      ctx.lineTo(slingshotX + 30, currentSlingshotY + 30);
      ctx.lineTo(slingshotX + 20, currentSlingshotY);
      ctx.lineTo(slingshotX - 20, currentSlingshotY);
      ctx.closePath();
      ctx.fill();

      // Draw Slingshot Prongs
      ctx.strokeStyle = '#5d4037';
      ctx.lineWidth = 6;

      ctx.beginPath();
      ctx.moveTo(slingshotX - 20, currentSlingshotY);
      ctx.lineTo(slingshotX - 20, currentSlingshotY - 50);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(slingshotX + 20, currentSlingshotY);
      ctx.lineTo(slingshotX + 20, currentSlingshotY - 50);
      ctx.stroke();
    }

    function drawBird() {
      ctx.fillStyle = bird.color;
      ctx.beginPath();
      ctx.arc(0, 0, bird.radius, 0, Math.PI * 2);
      ctx.fill();

      // Eyes (simple)
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(bird.radius * 0.4, -bird.radius * 0.3, bird.radius * 0.3, 0, Math.PI * 2);
      ctx.arc(-bird.radius * 0.4, -bird.radius * 0.3, bird.radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawTrajectory() {
      if (!bird.dragging) return;

      // Draw dashed trajectory line
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(bird.launchPoint.x, bird.launchPoint.y);
      ctx.lineTo(bird.x, bird.y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawBand(x1, y1, x2, y2) {
      ctx.lineWidth = 6;
      ctx.strokeStyle = '#5d4037';
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // --- COLLISION AND GAME LOGIC ---

    function checkHit(birdX, birdY, box) {
      const rect = box.getBoundingClientRect();
      const boxX = rect.left + rect.width / 2;
      const boxY = rect.top + rect.height / 2;

      const dx = birdX - boxX;
      const dy = birdY - boxY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Collision if center distance is less than bird radius + a small margin
      return distance < bird.radius + 15;
    }

    function detectCollision() {
      if (bird.dead) return;

      for (let i = 0; i < targetBoxes.length; i++) {
        const box = targetBoxes[i];
        if (box.style.opacity === '0') continue; // Already hit or disappeared

        if (checkHit(bird.x, bird.y, box)) {
          bird.dead = true;
          bird.launched = false; // Stop physics
          
          const optionIndex = parseInt(box.dataset.optionIndex);
          
          if (optionIndex === correctOptionIndex) {
            // Correct Hit!
            box.style.background = '#43a047'; // Darker green for correct hit
            box.classList.add('hit'); // Animate out
            score += 100;
            currentQuestionIndex++;
            
            // Wait for hit animation then load next question
            setTimeout(() => {
              targetBoxes.forEach(b => b.remove()); // Clean up
              targetBoxes = [];
              nextQuestion();
            }, 500);
            confettiEffect(15);
            
          } else {
            // Incorrect Hit
            box.style.background = '#d32f2f'; // Red for incorrect hit
            
            // Display the correct answer briefly
            targetBoxes[correctOptionIndex].style.background = '#0d47a1'; // Blue/Correct Highlight
            
            // Wait, then reset bird/end game
            setTimeout(() => {
                gameEnd(false); // Game Over on incorrect answer
            }, 1000); 
          }
          return;
        }
      }
      
      // Bird flew off screen
      if (bird.x > canvas.width || bird.y > canvas.height || bird.x < 0) {
        if (bird.launched) {
            bird.dead = true;
            bird.launched = false;
            
            // Missed all targets, show correct answer then Game Over
            targetBoxes[correctOptionIndex].style.background = '#0d47a1'; // Highlight correct answer
            
            setTimeout(() => {
                gameEnd(false); // Game Over on a miss
            }, 1500);
        }
      }
    }

    function confettiEffect(count) {
      for (let i = 0; i < count; i++) {
        const el = document.createElement('div');
        el.style.width = el.style.height = '10px';
        el.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
        el.style.position = 'absolute';
        el.style.borderRadius = '50%';
        el.style.zIndex = '999';
        el.style.left = bird.x + 'px';
        el.style.top = bird.y + 'px';
        
        // Add a slight random starting velocity for visual effect
        const vx = (Math.random() - 0.5) * 5;
        const vy = (Math.random() - 0.5) * 5;
        
        let x = bird.x;
        let y = bird.y;

        function fallAnimation() {
            if (y > window.innerHeight) {
                el.remove();
                return;
            }
            // Simple physics: small drag, gravity
            const gravity = 0.5;
            x += vx;
            y += vy + gravity;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            requestAnimationFrame(fallAnimation);
        }
        
        document.body.appendChild(el);
        fallAnimation();
      }
    }

    function animate() {
      if (paused) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const dy = currentSlingshotY; // Renamed for clarity

      // Draw Trajectory if dragging
      drawTrajectory();

      // Draw Band (Back)
      if (bird.dragging || (!bird.launched && (bird.x !== slingshotX || bird.y !== dy))) {
        drawBand(slingshotX - 20, dy - 50, bird.x, bird.y); // Attach to the left prong
      }

      // Physics
      if (bird.launched) {
        bird.vy += 0.6; 
        bird.x += bird.vx; 
        bird.y += bird.vy; 
        bird.vx *= 0.995; // Apply minor air resistance
        
        detectCollision();
      }
      
      // Bird goes off screen/dies
      if (bird.dead) {
          // Do not draw the bird if it's dead, let the reset logic handle next step
      } else {
        // Draw Bird
        ctx.save();
        ctx.translate(bird.x, bird.y);
        if (bird.launched) ctx.rotate(Math.atan2(bird.vy, bird.vx));
        drawBird();
        ctx.restore();
      }

      // Draw Band (Front) - only if dragging or still on slingshot
      if (bird.dragging || (!bird.launched && !bird.dead)) {
        drawBand(slingshotX + 20, dy - 50, bird.x, bird.y); // Attach to the right prong
      }

      // Draw Slingshot base (on top of the band)
      drawSlingshot();

      animationFrameId = requestAnimationFrame(animate);
    }

    // --- EVENT LISTENERS ---

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
      const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    function startDrag(e) {
      if (bird.launched || bird.dead || paused) return;
      const pos = getMousePos(e);
      
      // Check if click is near the unlaunched bird
      const dx = pos.x - bird.x;
      const dy = pos.y - bird.y;
      if (Math.sqrt(dx * dx + dy * dy) < bird.radius + 10) {
        bird.dragging = true;
        // Prevent default touch behavior if using touch events
        if (e.type.startsWith('touch')) e.preventDefault(); 
      }
    }

    function drag(e) {
      if (!bird.dragging || paused) return;
      const pos = getMousePos(e);
      
      let newX = pos.x;
      let newY = pos.y;
      
      // Calculate drag vector from the launch point
      const dx = newX - bird.launchPoint.x;
      const dy = newY - bird.launchPoint.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Limit drag distance
      if (distance > maxDragDistance) {
        const angle = Math.atan2(dy, dx);
        newX = bird.launchPoint.x + maxDragDistance * Math.cos(angle);
        newY = bird.launchPoint.y + maxDragDistance * Math.sin(angle);
      }
      
      // Ensure bird stays behind the slingshot anchor point
      if (newX > bird.launchPoint.x) newX = bird.launchPoint.x;

      bird.x = newX;
      bird.y = newY;
    }

    function launchBird() {
      if (!bird.dragging || paused) return;

      const launchX = bird.x;
      const launchY = bird.y;
      
      // Calculate velocity (inverted and scaled)
      bird.vx = (bird.launchPoint.x - launchX) * 0.2;
      bird.vy = (bird.launchPoint.y - launchY) * 0.2;
      
      bird.dragging = false;
      bird.launched = true;
    }

    // Canvas Events
    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', drag);
    canvas.addEventListener('mouseup', launchBird);

    // Touch Events for Mobile
    canvas.addEventListener('touchstart', startDrag, { passive: false });
    canvas.addEventListener('touchmove', drag, { passive: true });
    canvas.addEventListener('touchend', launchBird);

    window.addEventListener('resize', resizeCanvas);
    
    // Initial setup
    window.onload = function() {
      resizeCanvas();
      setupDashboard(); // Initializes the fetching of questions.json
      paused = true; // Start paused on the dashboard
    };
  </script>
</body>
</html>
